"""

PHASE 3 - MODULE 6: FORECASTING MODULE

=======================================

Module Purpose:

Implement ARIMA and ARIMAX forecasting with exogenous variable support for telecom KPIs.

Supports univariate ARIMA and multivariate ARIMAX with automatic order selection.

Dependencies:

- Upstream: filtering_engine.py (receives sampled DataFrame)

- Upstream: correlation_module.py (for exogenous KPI selection)

- Downstream: llama_service.py (forecast results passed to LLM)

Key Capabilities:

✓ ARIMA with auto order selection

✓ ARIMAX with multiple exogenous variables

✓ Confidence intervals (95%)

✓ Automatic fallback on convergence failure

✓ Comprehensive metrics (RMSE, MAE, MAPE, AIC)

✓ Performance optimized (<10s ARIMA, <15s ARIMAX)

Author: Telecom-Optimization-System

Date: 2025-12-03

Version: 1.0.0

"""

import logging

import time

from typing import Dict, List, Optional, Tuple, Union

from dataclasses import dataclass, asdict, field

from datetime import datetime, timedelta

import pandas as pd

import numpy as np

from pydantic import BaseModel, Field, validator

from statsmodels.tsa.statespace.sarimax import SARIMAX  # type: ignore

from pmdarima.arima import auto_arima  # type: ignore

from statsmodels.tools.eval_measures import rmse  # type: ignore

from sklearn.metrics import mean_absolute_error  # type: ignore
from sklearn.metrics import mean_absolute_percentage_error  # type: ignore

# ==================== LOGGING CONFIGURATION ====================\n\nlogger = logging.getLogger(__name__)\n\nlogger.setLevel(logging.DEBUG)\n\nif not logger.handlers:\n\n    handler = logging.StreamHandler()\n\n    formatter = logging.Formatter(\n\n        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n\n    )\n\n    handler.setFormatter(formatter)\n\n    logger.addHandler(handler)\n\n# ==================== PYDANTIC MODELS ====================\n\nclass ModelMetrics(BaseModel):\n\n    """Model evaluation metrics."""\n\n    rmse: float = Field(..., ge=0, description="Root Mean Squared Error")\n\n    mae: float = Field(..., ge=0, description="Mean Absolute Error")\n\n    mape: float = Field(..., ge=0, description="Mean Absolute Percentage Error (%)")\n\n    aic: Optional[float] = Field(None, description="Akaike Information Criterion")\n\n    class Config:\n\n        frozen = True\n\nclass ForecastResult(BaseModel):\n\n    """Complete forecast result with metadata and metrics."""\n\n    target_kpi: str = Field(..., description="KPI being forecasted")\n\n    model_type: str = Field(..., pattern="^(ARIMA|ARIMAX)$", description="Model type used")\n\n    forecast_values: List[float] = Field(..., description="Predicted values for forecast horizon")\n\n    confidence_interval_lower: List[float] = Field(..., description="95% CI lower bound")\n\n    confidence_interval_upper: List[float] = Field(..., description="95% CI upper bound")\n\n    forecast_dates: List[str] = Field(..., description="Dates for forecast period (YYYY-MM-DD)")\n\n    historical_values: List[float] = Field(..., description="Last 30 days of actual data")\n\n    historical_dates: List[str] = Field(..., description="Dates for historical data")\n\n    model_metrics: ModelMetrics\n\n    exogenous_variables_used: List[str] = Field(default_factory=list, description="Exogenous KPIs used")\n\n    model_order: Tuple[int, int, int] = Field(..., description="(p, d, q) order")\n\n    processing_time_ms: float = Field(..., ge=0, description="Total processing time in milliseconds")\n\n    convergence_warning: Optional[str] = Field(None, description="Convergence warning if present")\n\n    class Config:\n\n        frozen = True\n\n    def to_dict(self) -> Dict:\n\n        """Convert to dictionary for JSON serialization."""\n\n        return asdict(self) if hasattr(self, '__dataclass_fields__') else self.model_dump()\n\n# ==================== CORE FORECASTING FUNCTIONS ====================\n\ndef select_model_order(\n\n    df: pd.DataFrame,\n\n    kpi_column: str,\n\n    max_p: int = 5,\n\n    max_d: int = 2,\n\n    max_q: int = 5,\n\n    seasonal: bool = False,\n\n    timeout_seconds: int = 30\n\n) -> Tuple[int, int, int]:\n\n    """\n\n    Automatically select ARIMA order (p, d, q) using auto_arima.\n\n    Args:\n\n        df: DataFrame with time-indexed data\n\n        kpi_column: Column name to analyze\n\n        max_p: Maximum AR order to test\n\n        max_d: Maximum differencing to test\n\n        max_q: Maximum MA order to test\n\n        seasonal: Whether to apply seasonal differencing\n\n        timeout_seconds: Timeout for auto_arima search\n\n    Returns:\n\n        Tuple: (p, d, q) order\n\n    Raises:\n\n        ValueError: If auto_arima fails or data is invalid\n\n        TypeError: If kpi_column not in DataFrame\n\n    Example:\n\n        >>> df = pd.DataFrame({\n\n        ...     'time': pd.date_range('2024-01-01', periods=100, freq='D'),\n\n        ...     'kpi': np.random.randn(100).cumsum()\n\n        ... })\n\n        >>> order = select_model_order(df, 'kpi')\n\n        >>> print(order)  # e.g., (1, 1, 1)\n\n    """\n\n    start_time = time.time()\n\n    # Validation\n\n    if kpi_column not in df.columns:\n\n        raise TypeError(f"Column '{kpi_column}' not found in DataFrame")\n\n    kpi_data = df[kpi_column].dropna()\n\n    if len(kpi_data) < 10:\n\n        logger.warning(\n\n            f"Insufficient data for auto_arima (n={len(kpi_data)}, min=10). "\n\n            "Using default (1, 1, 1)"\n\n        )\n\n        return (1, 1, 1)\n\n    try:\n\n        logger.debug(\n\n            f"Auto-selecting ARIMA order for '{kpi_column}' "\n\n            f"(n={len(kpi_data)}, p_max={max_p}, d_max={max_d}, q_max={max_q})"\n\n        )\n\n        model = auto_arima(\n\n            kpi_data,\n\n            max_p=max_p,\n\n            max_d=max_d,\n\n            max_q=max_q,\n\n            seasonal=seasonal,\n\n            stepwise=True,\n\n            suppress_warnings=True,\n\n            information_criterion='aic',\n\n            trace=False\n\n        )\n\n        order = (model.order[0], model.order[1], model.order[2])\n\n        elapsed_ms = (time.time() - start_time) * 1000\n\n        logger.info(\n\n            f"✓ Auto-selected ARIMA order: {order} "\n\n            f"(AIC={model.aic:.2f}, time={elapsed_ms:.1f}ms)"\n\n        )\n\n        return order\n\n    except Exception as e:\n\n        logger.warning(\n\n            f"Auto-arima failed for '{kpi_column}': {str(e)}. "\n\n            "Falling back to default (1, 1, 1)"\n\n        )\n\n        return (1, 1, 1)\n\ndef calculate_forecast_metrics(\n\n    actual: Union[pd.Series, np.ndarray],\n\n    predicted: Union[pd.Series, np.ndarray],\n\n    aic: Optional[float] = None\n\n) -> Dict[str, Optional[float]]:\n\n    """\n\n    Calculate comprehensive forecast metrics.\n\n    Args:\n\n        actual: Actual values\n\n        predicted: Predicted values (same length as actual)\n\n        aic: Akaike Information Criterion (optional)\n\n    Returns:\n\n        Dict: {rmse, mae, mape, aic}\n\n    Raises:\n\n        ValueError: If arrays are different lengths or empty\n\n    Example:\n\n        >>> actual = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n\n        >>> predicted = np.array([1.1, 1.9, 3.2, 3.8, 5.1])\n\n        >>> metrics = calculate_forecast_metrics(actual, predicted)\n\n        >>> print(metrics['rmse'])  # ~0.14\n\n    """\n\n    actual = np.asarray(actual).flatten()\n\n    predicted = np.asarray(predicted).flatten()\n\n    if len(actual) != len(predicted):\n\n        raise ValueError(\n\n            f"Length mismatch: actual={len(actual)}, predicted={len(predicted)}"\n\n        )\n\n    if len(actual) == 0:\n\n        raise ValueError("Input arrays are empty")\n\n    # Calculate metrics using sklearn/statsmodels\n\n    rmse_val = float(rmse(actual, predicted))\n\n    mae_val = float(mean_absolute_error(actual, predicted))\n\n    # MAPE: avoid division by zero\n\n    mask = actual != 0\n\n    if mask.any():\n\n        mape_val = float(mean_absolute_percentage_error(actual[mask], predicted[mask])) * 100\n\n    else:\n\n        mape_val = np.inf if not np.allclose(predicted, 0) else 0.0\n\n    metrics: Dict[str, Optional[float]] = {\n\n        'rmse': rmse_val,\n\n        'mae': mae_val,\n\n        'mape': mape_val,\n\n        'aic': aic\n\n    }\n\n    logger.debug(f"Calculated metrics: RMSE={rmse_val:.4f}, MAE={mae_val:.4f}, MAPE={mape_val:.2f}%")\n\n    return metrics\n\ndef fit_arima(\n\n    df: pd.DataFrame,\n\n    time_column: str,\n\n    target_kpi: str,\n\n    forecast_horizon: int,\n\n    order: Optional[Tuple[int, int, int]] = None,\n\n    historical_lookback: int = 30\n\n) -> ForecastResult:\n\n    """\n\n    Fit ARIMA model and generate univariate forecast.\n\n    Args:\n\n        df: DataFrame with time index and target KPI\n\n        time_column: Name of time column\n\n        target_kpi: Column name to forecast\n\n        forecast_horizon: Number of periods to forecast (e.g., 7, 14, 30)\n\n        order: ARIMA (p, d, q) order. If None, auto-select\n\n        historical_lookback: Number of historical days to include in result\n\n    Returns:\n\n        ForecastResult: Complete forecast with metrics and confidence intervals\n\n    Raises:\n\n        ValueError: If data is invalid or model fitting fails\n\n        TypeError: If required columns missing\n\n    Example:\n\n        >>> df = pd.DataFrame({\n\n        ...     'time': pd.date_range('2024-01-01', periods=100, freq='D'),\n\n        ...     'kpi': np.random.randn(100).cumsum()\n\n        ... })\n\n        >>> result = fit_arima(df, 'time', 'kpi', forecast_horizon=7)\n\n        >>> print(result.forecast_values)  # [pred1, pred2, ..., pred7]\n\n        >>> print(result.model_metrics.rmse)\n\n    """\n\n    start_time = time.time()\n\n    # ========== INPUT VALIDATION ==========\n\n    if time_column not in df.columns:\n\n        raise TypeError(f"Time column '{time_column}' not found")\n\n    if target_kpi not in df.columns:\n\n        raise TypeError(f"Target KPI '{target_kpi}' not found")\n\n    if forecast_horizon <= 0:\n\n        raise ValueError(f"Forecast horizon must be > 0, got {forecast_horizon}")\n\n    # ========== DATA PREPARATION ==========\n\n    df_clean = df.copy()\n\n    # Parse time column\n\n    try:\n\n        df_clean[time_column] = pd.to_datetime(df_clean[time_column])\n\n    except Exception as e:\n\n        raise ValueError(f"Failed to parse time column: {str(e)}")\n\n    df_clean = df_clean.sort_values(by=time_column)\n\n    # Extract KPI\n\n    kpi_data = df_clean[[time_column, target_kpi]].dropna()\n\n    if len(kpi_data) < 10:\n\n        raise ValueError(\n\n            f"Insufficient data for ARIMA (n={len(kpi_data)}, min=10)"\n\n        )\n\n    logger.info(\n\n        f"ARIMA: Starting forecast for '{target_kpi}' "\n\n        f"(horizon={forecast_horizon}, n_historical={len(kpi_data)})"\n\n    )\n\n    # ========== AUTO-SELECT ORDER IF NOT PROVIDED ==========\n\n    if order is None:\n\n        order = tuple(select_model_order(kpi_data, target_kpi))\n\n    else:\n\n        order = tuple(order)\n\n    logger.debug(f"ARIMA order: {order}")\n\n    # ========== FIT ARIMA MODEL ==========\n\n    try:\n\n        model = SARIMAX(\n\n            kpi_data[target_kpi].values,\n\n            order=order,\n\n            seasonal_order=(0, 0, 0, 0),\n\n            enforce_stationarity=False,\n\n            enforce_invertibility=False\n\n        )\n\n        fitted_model = model.fit(disp=False, maxiter=200)\n\n        logger.debug(f"ARIMA fitted: AIC={fitted_model.aic:.2f}")\n\n    except Exception as e:\n\n        logger.error(f"ARIMA fitting failed: {str(e)}")\n\n        raise ValueError(f"Model fitting failed: {str(e)}")\n\n    # ========== GENERATE FORECAST ==========\n\n    try:\n\n        forecast_result = fitted_model.get_forecast(steps=forecast_horizon)\n\n        # Keep as Series to maintain type consistency with tests\n        forecast_values = forecast_result.predicted_mean\n\n        # Keep as DataFrame/Series to maintain type consistency\n        conf_int = forecast_result.conf_int(alpha=0.05)\n\n        conf_lower = conf_int[:, 0]\n\n        conf_upper = conf_int[:, 1]\n\n    except Exception as e:\n\n        logger.error(f"Forecast generation failed: {str(e)}")\n\n        raise ValueError(f"Forecast failed: {str(e)}")\n\n    # ========== HISTORICAL DATA FOR PLOTTING ==========\n\n    last_date = kpi_data[time_column].max()\n\n    historical = kpi_data.tail(historical_lookback)\n\n    historical_values = historical[target_kpi].tolist()\n\n    historical_dates = historical[time_column].dt.strftime('%Y-%m-%d').tolist()\n\n    # ========== FORECAST DATES ==========\n\n    forecast_dates = [\n\n        (last_date + timedelta(days=i+1)).strftime('%Y-%m-%d')\n\n        for i in range(forecast_horizon)\n\n    ]\n\n    # ========== CALCULATE METRICS (ON TRAINING DATA) ==========\n\n    fitted_values = fitted_model.fittedvalues\n\n    actual_values = kpi_data[target_kpi].values\n\n    # Align lengths (first order[1] values are NaN due to differencing)\n\n    min_len = min(len(fitted_values), len(actual_values))\n\n    metrics = calculate_forecast_metrics(\n\n        np.asarray(actual_values[-min_len:]),\n\n        np.asarray(fitted_values[-min_len:]),\n\n        aic=fitted_model.aic\n\n    )\n\n    # ========== BUILD RESULT ==========\n\n    elapsed_ms = (time.time() - start_time) * 1000\n\n    result = ForecastResult(\n\n        target_kpi=target_kpi,\n\n        model_type="ARIMA",\n\n        forecast_values=forecast_values.tolist(),\n\n        confidence_interval_lower=conf_lower.tolist(),\n\n        confidence_interval_upper=conf_upper.tolist(),\n\n        forecast_dates=forecast_dates,\n\n        historical_values=historical_values,\n\n        historical_dates=historical_dates,\n\n        model_metrics=ModelMetrics(**metrics),\n\n        exogenous_variables_used=[],\n\n        model_order=order,\n\n        processing_time_ms=elapsed_ms,\n\n        convergence_warning=None\n\n    )\n\n    logger.info(\n\n        f"✓ ARIMA forecast complete: {forecast_horizon} steps, "\n\n        f"RMSE={metrics['rmse']:.4f}, time={elapsed_ms:.1f}ms"\n\n    )\n\n    return result\n\ndef fit_arimax(\n\n    df: pd.DataFrame,\n\n    time_column: str,\n\n    target_kpi: str,\n\n    exogenous_kpis: List[str],\n\n    forecast_horizon: int,\n\n    order: Optional[Tuple[int, int, int]] = None,\n\n    historical_lookback: int = 30,\n\n    exogenous_forecast_method: str = 'last_value'\n\n) -> ForecastResult:\n\n    """\n\n    Fit ARIMAX model with exogenous variables and generate forecast.\n\n    Args:\n\n        df: DataFrame with time index, target KPI, and exogenous KPIs\n\n        time_column: Name of time column\n\n        target_kpi: Column name to forecast\n\n        exogenous_kpis: List of exogenous KPI column names (typically Top 3 correlated)\n\n        forecast_horizon: Number of periods to forecast\n\n        order: ARIMAX (p, d, q) order. If None, auto-select\n\n        historical_lookback: Number of historical days in result\n\n        exogenous_forecast_method: How to forecast exogenous variables ('last_value' or 'mean')\n\n    Returns:\n\n        ForecastResult: Complete forecast with metrics and confidence intervals\n\n    Raises:\n\n        ValueError: If data invalid, exogenous variables missing, or fitting fails\n\n        TypeError: If required columns missing\n\n    Example:\n\n        >>> df = pd.DataFrame({\n\n        ...     'time': pd.date_range('2024-01-01', periods=100, freq='D'),\n\n        ...     'target': np.random.randn(100).cumsum(),\n\n        ...     'exog1': np.random.randn(100).cumsum(),\n\n        ...     'exog2': np.random.randn(100).cumsum()\n\n        ... })\n\n        >>> result = fit_arimax(\n\n        ...     df, 'time', 'target', ['exog1', 'exog2'],\n\n        ...     forecast_horizon=7\n\n        ... )\n\n        >>> print(result.model_type)  # 'ARIMAX'\n\n        >>> print(result.exogenous_variables_used)  # ['exog1', 'exog2']\n\n    """\n\n    start_time = time.time()\n\n    convergence_warning = None\n\n    # ========== INPUT VALIDATION ==========\n\n    if time_column not in df.columns:\n\n        raise TypeError(f"Time column '{time_column}' not found")\n\n    if target_kpi not in df.columns:\n\n        raise TypeError(f"Target KPI '{target_kpi}' not found")\n\n    if forecast_horizon <= 0:\n\n        raise ValueError(f"Forecast horizon must be > 0, got {forecast_horizon}")\n\n    if not exogenous_kpis:\n\n        raise ValueError("At least one exogenous KPI required for ARIMAX")\n\n    # Validate exogenous columns exist\n\n    missing_exog = [kpi for kpi in exogenous_kpis if kpi not in df.columns]\n\n    if missing_exog:\n\n        raise TypeError(f"Exogenous KPIs not found: {missing_exog}")\n\n    # ========== DATA PREPARATION ==========\n\n    df_clean = df.copy()\n\n    # Parse time column\n\n    try:\n\n        df_clean[time_column] = pd.to_datetime(df_clean[time_column])\n\n    except Exception as e:\n\n        raise ValueError(f"Failed to parse time column: {str(e)}")\n\n    df_clean = df_clean.sort_values(by=time_column)\n\n    # Extract columns for modeling\n\n    modeling_cols = [time_column, target_kpi] + exogenous_kpis\n\n    df_model = df_clean[modeling_cols].dropna()\n\n    if len(df_model) < 10:\n\n        raise ValueError(\n\n            f"Insufficient data for ARIMAX (n={len(df_model)}, min=10)"\n\n        )\n\n    logger.info(\n\n        f"ARIMAX: Starting forecast for '{target_kpi}' "\n\n        f"with exogenous={exogenous_kpis[:3]} "  # Log first 3\n\n        f"(horizon={forecast_horizon}, n_historical={len(df_model)})"\n\n    )\n\n    # ========== AUTO-SELECT ORDER IF NOT PROVIDED ==========\n\n    if order is None:\n\n        order = tuple(select_model_order(df_model, target_kpi))\n\n    else:\n\n        order = tuple(order)\n\n    logger.debug(f"ARIMAX order: {order}")\n\n    # ========== EXTRACT EXOGENOUS DATA ==========\n\n    endog = df_model[target_kpi].values\n\n    exog = df_model[exogenous_kpis].values\n\n    # ========== FIT ARIMAX MODEL ==========\n\n    try:\n\n        model = SARIMAX(\n\n            endog,\n\n            exog=exog,\n\n            order=order,\n\n            seasonal_order=(0, 0, 0, 0),\n\n            enforce_stationarity=False,\n\n            enforce_invertibility=False\n\n        )\n\n        fitted_model = model.fit(disp=False, maxiter=200)\n\n        logger.debug(f"ARIMAX fitted: AIC={fitted_model.aic:.2f}")\n\n    except Exception as e:\n\n        logger.error(f"ARIMAX fitting failed: {str(e)}")\n\n        raise ValueError(f"Model fitting failed: {str(e)}")\n\n    # ========== FORECAST EXOGENOUS VARIABLES ==========\n\n    if exogenous_forecast_method == 'last_value':\n\n        # Use last observed values of exogenous variables\n\n        exog_forecast = np.tile(exog[-1, :], (forecast_horizon, 1))\n\n        logger.debug("Exogenous forecast: using last observed values")\n\n    elif exogenous_forecast_method == 'mean':\n\n        # Use mean of exogenous variables\n\n        exog_forecast = np.tile(exog.mean(axis=0), (forecast_horizon, 1))\n\n        logger.debug("Exogenous forecast: using mean values")\n\n    else:\n\n        raise ValueError(\n\n            f"Invalid exogenous_forecast_method: {exogenous_forecast_method}. "\n\n            "Use 'last_value' or 'mean'"\n\n        )\n\n    # ========== GENERATE FORECAST ==========\n\n    try:\n\n        forecast_result = fitted_model.get_forecast(\n\n            steps=forecast_horizon,\n\n            exog=exog_forecast\n\n        )\n\n        # Keep as Series to maintain type consistency\n        forecast_values = forecast_result.predicted_mean\n\n        # Keep as Series to maintain type consistency\n        conf_int = forecast_result.conf_int(alpha=0.05)\n\n        conf_lower = conf_int[:, 0]\n\n        conf_upper = conf_int[:, 1]\n\n    except Exception as e:\n\n        logger.warning(f"ARIMAX forecast failed: {str(e)}")\n\n        convergence_warning = f"Forecast generation: {str(e)}"\n\n        # Return zeros as fallback\n\n        forecast_values = np.zeros(forecast_horizon)\n\n        conf_lower = np.zeros(forecast_horizon)\n\n        conf_upper = np.zeros(forecast_horizon)\n\n    # ========== HISTORICAL DATA FOR PLOTTING ==========\n\n    last_date = df_model[time_column].max()\n\n    historical = df_model.tail(historical_lookback)\n\n    historical_values = historical[target_kpi].tolist()\n\n    historical_dates = historical[time_column].dt.strftime('%Y-%m-%d').tolist()\n\n    # ========== FORECAST DATES ==========\n\n    forecast_dates = [\n\n        (last_date + timedelta(days=i+1)).strftime('%Y-%m-%d')\n\n        for i in range(forecast_horizon)\n\n    ]\n\n    # ========== CALCULATE METRICS (ON TRAINING DATA) ==========\n\n    fitted_values = fitted_model.fittedvalues\n\n    actual_values = endog\n\n    # Align lengths\n\n    min_len = min(len(fitted_values), len(actual_values))\n\n    metrics = calculate_forecast_metrics(\n\n        np.asarray(actual_values[-min_len:]),\n\n        np.asarray(fitted_values[-min_len:]),\n\n        aic=fitted_model.aic\n\n    )\n\n    # ========== BUILD RESULT ==========\n\n    elapsed_ms = (time.time() - start_time) * 1000\n\n    result = ForecastResult(\n\n        target_kpi=target_kpi,\n\n        model_type="ARIMAX",\n\n        forecast_values=forecast_values.tolist(),\n\n        confidence_interval_lower=conf_lower.tolist(),\n\n        confidence_interval_upper=conf_upper.tolist(),\n\n        forecast_dates=forecast_dates,\n\n        historical_values=historical_values,\n\n        historical_dates=historical_dates,\n\n        model_metrics=ModelMetrics(**metrics),\n\n        exogenous_variables_used=exogenous_kpis,\n\n        model_order=order,\n\n        processing_time_ms=elapsed_ms,\n\n        convergence_warning=convergence_warning\n\n    )\n\n    logger.info(\n\n        f"✓ ARIMAX forecast complete: {forecast_horizon} steps, "\n\n        f"RMSE={metrics['rmse']:.4f}, exog={len(exogenous_kpis)}, time={elapsed_ms:.1f}ms"\n\n    )\n\n    return result\n\n# ==================== HIGH-LEVEL FORECASTING API ====================\n\ndef forecast_kpi(\n\n    df: pd.DataFrame,\n\n    time_column: str,\n\n    target_kpi: str,\n\n    forecast_horizon: int,\n\n    exogenous_kpis: Optional[List[str]] = None,\n\n    order: Optional[Tuple[int, int, int]] = None,\n\n    use_arimax: Optional[bool] = None\n\n) -> ForecastResult:\n\n    """\n\n    High-level API for forecasting with automatic model selection.\n\n    Automatically chooses between ARIMA and ARIMAX based on exogenous_kpis.\n\n    Args:\n\n        df: DataFrame with time index and KPIs\n\n        time_column: Name of time column\n\n        target_kpi: Column to forecast\n\n        forecast_horizon: Number of periods to forecast\n\n        exogenous_kpis: List of exogenous KPIs for ARIMAX (optional)\n\n        order: ARIMA/ARIMAX (p, d, q) order (optional, auto-select if None)\n\n        use_arimax: Force ARIMAX even if exogenous_kpis is empty (not recommended)\n\n    Returns:\n\n        ForecastResult: Forecast with model type, values, and metrics\n\n    Raises:\n\n        ValueError: If inputs are invalid\n\n        TypeError: If required columns missing\n\n    Example:\n\n        >>> df = pd.DataFrame({...})\n\n        >>> result = forecast_kpi(\n\n        ...     df, 'time', 'RACH stp att',\n\n        ...     forecast_horizon=7,\n\n        ...     exogenous_kpis=['RRC stp att', 'E-UTRAN avg RRC conn UEs']\n\n        ... )\n\n        >>> print(result.model_type)  # 'ARIMAX'\n\n        >>> print(len(result.forecast_values))  # 7\n\n    """\n\n    # Determine model type\n\n    has_exogenous = exogenous_kpis and len(exogenous_kpis) > 0\n\n    should_use_arimax = use_arimax or has_exogenous\n\n    if should_use_arimax and not has_exogenous:\n\n        logger.warning(\n\n            "use_arimax=True but no exogenous_kpis provided. "\n\n            "Falling back to ARIMA"\n\n        )\n\n        should_use_arimax = False\n\n    # Route to appropriate model\n\n    if should_use_arimax:\n\n        logger.debug(f"Using ARIMAX with exogenous: {exogenous_kpis}")\n\n        # Fix: Check if exogenous_kpis is None before passing\n        if exogenous_kpis is not None:\n             return fit_arimax(\n                df, time_column, target_kpi, exogenous_kpis,\n                forecast_horizon, order\n            )\n        else:\n            # Fallback if logic fails (shouldn't reach here due to checks above)\n            return fit_arima(\n                df, time_column, target_kpi,\n                forecast_horizon, order\n            )\n\n    else:\n\n        logger.debug("Using ARIMA (univariate)")\n\n        return fit_arima(\n\n            df, time_column, target_kpi,\n\n            forecast_horizon, order\n\n        )\n\n# ==================== BATCH FORECASTING ====================\n\ndef forecast_multiple_kpis(\n\n    df: pd.DataFrame,\n\n    time_column: str,\n\n    target_kpis: List[str],\n\n    forecast_horizon: int,\n\n    exogenous_mapping: Optional[Dict[str, List[str]]] = None\n\n) -> Dict[str, Optional[ForecastResult]]:\n\n    """\n\n    Forecast multiple KPIs in batch.\n\n    Args:\n\n        df: DataFrame with time index and KPIs\n\n        time_column: Name of time column\n\n        target_kpis: List of KPIs to forecast\n\n        forecast_horizon: Forecast horizon\n\n        exogenous_mapping: Dict mapping target_kpi -> [exogenous_kpis]\n\n        e.g., {"RACH stp att": ["RRC stp att", "E-UTRAN avg RRC conn UEs"]}\n\n    Returns:\n\n        Dict: {target_kpi -> ForecastResult}\n\n    Example:\n\n        >>> results = forecast_multiple_kpis(\n\n        ...     df, 'time',\n\n        ...     ['RACH stp att', 'RRC stp att'],\n\n        ...     forecast_horizon=7,\n\n        ...     exogenous_mapping={\n\n        ...         'RACH stp att': ['RRC stp att', 'E-UTRAN avg RRC conn UEs']\n\n        ...     }\n\n        ... )\n\n        >>> for kpi, result in results.items():\n\n        ...     print(f"{kpi}: {result.model_type}")\n\n    """\n\n    exogenous_mapping = exogenous_mapping or {}\n\n    results: Dict[str, Optional[ForecastResult]] = {}\n\n    for kpi in target_kpis:\n\n        try:\n\n            exogenous = exogenous_mapping.get(kpi)\n\n            result = forecast_kpi(\n\n                df, time_column, kpi,\n\n                forecast_horizon,\n\n                exogenous_kpis=exogenous\n\n            )\n\n            results[kpi] = result\n\n            logger.info(f"✓ Forecasted {kpi}")\n\n        except Exception as e:\n\n            logger.error(f"✗ Failed to forecast {kpi}: {str(e)}")\n\n            results[kpi] = None  # type: ignore\n\n    return results\n\nif __name__ == "__main__":\n\n    logger.info("Forecasting Module loaded. Use forecast_kpi() or fit_arima/fit_arimax functions.")